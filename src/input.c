#include <compositor.h>
#include <xkbcommon/xkbcommon.h>
#include <xkbcommon/xkbcommon-names.h>
#include <xkbcommon/xkbcommon-keysyms.h>
#include <sequential.h>
#include <tree.h>

extern struct weston_seat *seat0;

/**
 * thanks to the knowledge by archwiki, the xkbcommon is the library that does
 * all the mapping, it has
 * - model:"pc105, pc104, cheryblue, emachines...",
 * - layouts: "languages like us, fr",
 * - variants: "dvorak" keyboard for us layouts, anyway, people always wanna new
     different keyboard.
 * - options: the one I use is 'switch lctrl-lalt'
 *
 * In weston, the key event is called by generated by notify_key, some backends
 * like x11/wayland will call it directly, drm seems to have different
 * approaches since it is more complecated. You should add the seat created
 * signal though. well, anyway. We are getting the input
 *
 */
struct tw_keypress {
	list_t command;
	xkb_keysym_t keysym;
};
#define list2keypress(ptr)	container_of(ptr, struct tw_keypress, command)

//yoo, I should define bunch of hotkey function.
typedef void (*shortcut_func_t)(void);

//at the layer, you only need to know one key
struct tw_keymap_tree {
	//struct list_t *keyseq;
	xkb_keysym_t keysym;
	struct vtree_node node;
	//also a function should be here
	shortcut_func_t keyfun;
} root;

//static struct tw_keymap_tree *root;
#define node2treekeymap(ptr)	container_of(ptr, struct tw_keymap_tree, node)


static uint32_t
kc_linux2xkb(uint32_t kc_linux)
{
	//this should only work on x11, but very weird it works all the time
	return kc_linux+8;
}

static uint32_t
kc_xkb2linux(uint32_t kc_xkb)
{
	return kc_xkb-8;
}

//
void
update_tw_keymap_tree(struct tw_keymap_tree *root, struct list_t *keyseq)
{
	struct tw_keypress *ks = list2keypress(keyseq);
//	list_for_each(keysym, ks, command) {

//	}
}


void
run_keybinding(struct weston_keyboard *keyboard,
	       uint32_t time, uint32_t key,
	       void *data)
{
	static struct tw_keymap_tree *keybinding_tree = &root;

	xkb_keycode_t keycode = kc_linux2xkb(key);
	xkb_keysym_t  keysym  = xkb_state_key_get_one_sym(keyboard->xkb_state.state,
							  keycode);
	//search the key in the children
	bool hit = false;
	for (int i = 0; i < keybinding_tree->node.children.len; i++) {
		struct vtree_node *node = deref(struct vtree_node **,
						vector_at(&keybinding_tree->node.children, i));
		struct tw_keymap_tree *binding = node2treekeymap(node);
		if (binding->keysym == keysym && binding->keyfun) {
			//set back to origin;
			keybinding_tree = &root;
			binding->keyfun();
			hit = true;
			break;
		} else if (binding->keysym == keysym && !binding->keyfun) {
			keybinding_tree = binding;
			hit = true;
			break;
		}
	}
	//unregistered keybinding, it could happen. But in this case, we
	//shouldn't pass the key to the clients anyway
	if (!hit) {
		keybinding_tree = &root;
	}
}


//test the translation between xkbcommon and linux scan code
/*
int main(int argc, char *argv[])
{

	return 0;
}
*/
