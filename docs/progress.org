* Stage one: basic libweston compositor
  - have interface(shell and launcher)
  - cursor, keyboard are fully function.
  - be able to launch and close applications.

** [100%] fully nuklear backend (utilizing app-surface and)
     - ~nk_input_key~ and ~nk_input_unicode~ carries the text input. But the
       input box details is unknown.
*** CANC draw another triangle above nuklear widget
*** DONE research the mouse clicking problem
    Nvidia driver specific problem.
** [100%] Taiwins-shell
*** CANC lua support
    this can be *later*. It is very independent.
**** DOIN adding text to widget APIs.
*** DONE memory leak checking
**** Possible leaking ::
     - malloc but no free(I probably don't have that).
     - opened file without closing(socket, epoll, log file)
     - other system resources I am not aware of
     - libweston(-eglstream) leaks, since nvidia's implementation is not very
       serious
     - ~wl_callback~ :: there may be a wl_callback not destroyed. For this we
			would have to store the wl_callback specifically

**** DONE nuklear memory checking
**** DONE cairo memory checking

** [100%] Taiwins-launcher
*** DONE showing the luancher window
*** DONE implement text_editing                                      :client:
    Tab works
*** DONE fork-exec                                                   :client:

*** DONE change the ui element start or close implimentation

* Stage two: optimization
  - supporting multiple monitors/seats.
  - weston view focus defocus
  - a few different extensions.
  - lua support for writing extensions.
  - different layouting support
  - resize EGL windows.
  - compositing
** [50%] server-side optimization
*** DONE singals for adding new output and seats
*** TODO rendering/compositing optimization(what did this mean again)?

** [0%] Configurations
*** TODO styles, nuklear and other widget styles.
    - background color.
    - Font size, font selection.

*** DONE keyboard callbacks, this writes to a buffer, apparently.

** [60%] libweston-desktop implementation                            :server:
*** DONE desktop layer architecture
*** DONE simple random floating implementation
*** TODO tiling layout
**** TODO ML based layout

*** TODO client search buffer                                         :proto:
    for this to work, we probably will need ~radix tree~ or ~trie~ or hash
    table.
*** DONE decoupling the desktop implementation                    :refactory:

** [50%] client-side optimization
*** DONE find a way to read dispatch wl_display without blocking
    - possible solution :: maybe we can use epoll on wl_display, and add it to
	 our event_queue, so we can call ~wl_display_dispatch_pending~. We don't
	 need another thread anymore.
*** TODO resize EGL window
* Stage three: extensions
  - screen capture and screen record(audio support?).
  - westons's zoom support.




* Bugs
** a completion based text_edit
   - ~nk_egl_get_key~ gets NoSymbol very 2 frames, so if you press Tab twice,
     what you get is Tab -> NoSymbol -> Tab -> NoSymbol. NoSymbol resets the
     state.
   - solution :: return on NoSymbol

** HARD!! compositor doesn't emit the ~done~ event for clients.
   - ~frame_callback~ was created in ~surface_state~, moved to ~surface~ at
     commit, emit ~done~ at repaint. And repaint only works if you have a view
     in the compositor. ~weston_view_unmap~ removes the view from compositor. In
     this case, the ~frame_callback~ stayed in the surface.

     In our case for the ui element, we need the frame to start and finish well,
     since next frame may starts with different content.
*** failed solution( LAGGY ):
    - unmap the view :: unmap the view removes view immediately out of any of
			~layer_list~, compositor's ~view_list~. So the frame
			~done~ would never get called either. So when the views
			move back to the layer let's say, next repaint should
			emit ~done~. However, at ~set_launcher~, we will
			immediately have another ~commit~, this can happen
			before next repaint(and it happens every time). In other
			words, so we will have one commit ahead, thus causes
			lag.
    - uses a hidden layer :: does the same thing above, since
	 ~weston_output_repaint~ does the ~view_list~ building. The view moves
	 out of the compositor before sending done.
    - do not commit in client :: cannot guarantee no commits after then submit
	 request, will also causes the lag as well.
*** UGLY solution
    - send done yourself :: copy the frame_callback struct then send the done.
*** Final solution (using frame_signal)
    the frame_signal in the ~weston_output~ struct is for the recorder. But it
    suits our case
