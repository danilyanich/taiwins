* Stage one: basic libweston compositor
  - have interface(shell and launcher)
  - cursor, keyboard are fully functioned.
  - be able to launch and close applications.

** [100%] fully nuklear backend (utilizing app-surface and)
     - ~nk_input_key~ and ~nk_input_unicode~ carries the text input. But the
       input box details is unknown.
*** CANC draw another triangle above nuklear widget
*** DONE research the mouse clicking problem
    Nvidia driver specific problem.
** [100%] Taiwins-shell
*** CANC lua support
    this can be *later*. It is very independent.
**** DONE adding text to widget APIs.
*** DONE memory leak checking
    My code does not have memory leak, the only problem happens with opengl drivers

**** Possible leaking ::
     - malloc but no free(I probably don't have that).
     - opened file without closing(socket, epoll, log file)
     - other system resources I am not aware of
     - libweston(-eglstream) leaks, since nvidia's implementation is not very
       serious
     - ~wl_callback~ :: there may be a wl_callback not destroyed. For this we
			would have to store the wl_callback specifically

**** DONE nuklear memory checking
**** DONE cairo memory checking


** [100%] Taiwins-launcher
*** DONE showing the luancher window
*** DONE implement text_editing                                      :client:
    Tab works
*** DONE fork-exec                                                   :client:

*** DONE change the ui element start or close implimentation

* [14%] Stage two: feature completion
  - supporting multiple monitors/seats.
  - weston view focus defocus
  - a few different extensions.
  - lua support for writing extensions.
  - different layouting support
  - resize EGL windows.
  - compositing
** DONE renaming tw_shell -> shell, tw_desktop -> desktop.
   so the protocols can directly use tw_shell instead of taiwins_shell
** DOIN [55%] server-side optimization
*** DONE rename all the ctype functions.
    I did move them into uppercase macros.

*** DONE singals for adding new output and seats
*** TODO change the keyboard grab allowing the long pressing.
*** DONE updated to libweston-5
    - figure out the bug for libdrm backend.
      turned out it is my stupid pointer assignment
*** DOIN finishing weston_desktop protocols
    - resizing. DONE
    - maximizing.
    - minimizing
    - recent views
*** DOIN switch bindings into our ~run_binding~ callbacks
    looks like I need a patched version of libweston to get it to work
*** DONE have functional workspace implementation
    - workspace is implemented as keybindings
*** DONE refactring that layout implementation in workspace, it is ugly
*** TODO setup the xkb context and all that stuff
** DOIN [50%] Configurations
*** TODO introduce the lua code
*** DONE styles, nuklear and other widget styles.
    - background color.
    - Font size, font selection.
*** DONE keyboard callbacks, this writes to a buffer, apparently.
*** TODO shortcuts `taiwins_zoom`, `taiwins_alpha`. Move them into ~config.h~

** DOIN [57%] libweston-desktop implementation                       :server:
*** DOIN implement the libweston-desktop protocol                     :proto:
*** DONE desktop layer architecture
*** DONE simple random floating implementation
*** DOIN tiling layout
*** TODO client search buffer                                         :proto:
    for this to work, we probably will need ~radix tree~ or ~trie~ or hash
    table.
*** DONE decoupling the desktop implementation                    :refactory:
*** DONE include a ~last-focused-view-list~ per workspace?
    luckly that we have ~weston_desktop_suface_set_user_data~, it seems to fit
    perfectly in that position

** DOIN [71%] client-side optimization
*** TODO add udev monitoring and inotify monitoring to event_queue
*** TODO properly handling the frame callbacks for ~app_surface~
    one solution is implementing all the input handling in the wayland frame
    callback. But this wont be agonositc though.
*** TODO implement scale for shell and console
*** DONE switch to epoll on wl_display
    - possible solution :: maybe we can use epoll on wl_display, and add it to
	 our event_queue, so we can call ~wl_display_dispatch_pending~. We don't
	 need another thread anymore.
*** CANC resize EGL window
    I didn't do it eventually, using different wl_surface become a solution
*** DONE shell panel refactoring
    replace the panel to nuklear implementation
*** DONE fix the cursor input problem(maybe just forget about the cursor frame callback), what is this??
*** CANC move the wl_cursor surface into shell?
    Maybe I am wrong. I do need the cursor for every application.
*** DONE widget surface launch code.
*** DONE second widget, reading batteries
*** TODO adding support for notification
*** TODO adding support for cursor menu
    right click and left click provides different functions
    - preferably right click open an menu and left click opens selection.
    - for this work you need the support for resizing
*** DONE make changes into ~tw_event_queue~
    ~tw_event_queue~ now supports more operations, you can add onetime timer then
    tell the ~queue~ to delete it afterwards, and you can change fd at runtime
    to watch on different files.

*** DONE find a way to add leading space in panel
    ~nk_spacing~ is the good solution, but you need to calculate the layout size
*** DONE fix the multiple launching bug in the panel
*** CANC add another row for panel to have better look?
*** DONE change the way the nk_button look for the icons.
*** DONE decide the way to render icons more properly.
    Right now we rely on font awesome.

    The ideal solution is render icons into glyphs. More conviniently is by
    using SVGs, since you can find them anymore. But there is no valid c or
    c++ implementation of svg2ttf. We need to rely on fontawesome for now. Now
    you need to include this [https://github.com/juliettef/IconFontCppHeaders]
    for mapping unicode symbols.
*** DOIN nk_vulkan backend
    This work is not necessary, only serves the purpose of vulkan
    training. Since nvidia really does not have the ~VK_KHR_wayland_surface~, we
    have to implement it in a total different way. Once you are done with
    it. You can implement ~vulkan-hpp~.
*** DONE intergrate nk_wl_egl into nk_wl_backend
    I implemented a template header of ~nk_wl_internal~, but never actually
    applies it to nk_wl_egl, it should be done very soon, so I can totally
    remove the deprecated functions.
*** DONE nk_cairo_backend multiple font support
** DOIN [33%] launcher optimization
*** DONE renaming launcher into commander, since it will does much more than just launching
*** TODO allow launcher to quit instead of launch weston-terminal all the time
*** TODO the real launcher implementation
** DOIN [50%] protocols                                               :proto:
*** DONE `tw_output` protocols to represent logical output
*** TODO `tw_desktop` output to recieve desktop events

* Stage three: extensions
*** TODO deal with scale
    you can start it by experiment with updating ~weston_matrix~
*** TODO ML based layout
*** TODO rendering/compositing optimization.
  - screen capture and screen record(audio support?).
  - westons's zoom support.

*** TODO update with damage
    currently you do only ~wl_surface_damage(0, 0, w, h)~, which causes whole
    buffer to redraw, I think there is a better solution for that.
*** TODO svg2ttf implementation
*** TODO supporting examing buffer
*** TODO build weston along with taiwins(with meson maybe)
* [20%] Bugs
** a completion based text_edit
   - ~nk_egl_get_key~ gets NoSymbol very 2 frames, so if you press Tab twice,
     what you get is Tab -> NoSymbol -> Tab -> NoSymbol. NoSymbol resets the
     state.
   - solution :: return on NoSymbol

** HARD!! compositor doesn't emit the ~done~ event for clients.
   - ~frame_callback~ was created in ~surface_state~, moved to ~surface~ at
     commit, emit ~done~ at repaint. And repaint only works if you have a view
     in the compositor. ~weston_view_unmap~ removes the view from compositor. In
     this case, the ~frame_callback~ stayed in the surface.

     In our case for the ui element, we need the frame to start and finish well,
     since next frame may starts with different content.
*** failed solution( LAGGY ):
    - unmap the view :: unmap the view removes view immediately out of any of
			~layer_list~, compositor's ~view_list~. So the frame
			~done~ would never get called either. So when the views
			move back to the layer let's say, next repaint should
			emit ~done~. However, at ~set_launcher~, we will
			immediately have another ~commit~, this can happen
			before next repaint(and it happens every time). In other
			words, so we will have one commit ahead, thus causes
			lag.
    - uses a hidden layer :: does the same thing above, since
	 ~weston_output_repaint~ does the ~view_list~ building. The view moves
	 out of the compositor before sending done.
    - do not commit in client :: cannot guarantee no commits after then submit
	 request, will also causes the lag as well.
*** UGLY solution
    - send done yourself :: copy the frame_callback struct then send the done.
*** Final solution (using frame_signal)
    the frame_signal in the ~weston_output~ struct is for the recorder. But it
    suits our case

** TODO somehow EGL did not have effects on the first draw call
   currently I have to use background color as a hack, which I hate it, or you
   can just have empty draw call
** TODO libEGL warning: FIXME: egl/x11 doesn't support front buffer rendering.
   Seems has something to do with ~EGLMakeCurrent()~.
** DONE find out why all the code point becomes `?`
   the ~nk_rune~ has to be available all the time as nuklear does not like to
   manage memory, so you cannot just pass an temporary address.
** TODO nuklear input handling has problems, the button clicked state retains
** TODO nvidia egl driver keeps giving me errors after closing an app
** TODO EGL memory leak
   after testing with cairo backend, I can be sure that my code does not contain
   any memory leak, so the problem lies within EGL side
