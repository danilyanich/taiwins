<protocol name="taiwins_desktop">

  <interface name="taiwins_shell" version="1">
    <description summary="create desktop widgets and helpers">
      Traditional user interfaces can rely on this interface to define the
      foundations of typical desktops. Currently it's possible to set up
      background, panels and locking surfaces.
    </description>

    <request name="set_background">
      <arg name="output" type="object" interface="wl_output"/>
      <arg name="surface" type="object" interface="wl_surface"/>
    </request>

    <!-- new api, so deprecate the old set_widget and hide_widget -->
    <request name="create_panel">
      <description summary="create a new widget from wl_surface"/>
      <arg name="tw_ui" type="new_id" interface="tw_ui"/>
      <arg name="wl_surface" type="object" interface="wl_surface"/>
      <arg name="tw_output" type="object" interface="tw_output"/>
    </request>

    <request name="create_background">
      <description summary="create a background for a logical output"/>
      <arg name="tw_ui" type="new_id" interface="tw_ui"/>
      <arg name="wl_surface" type="object" interface="wl_surface"/>
      <arg name="tw_output" type="object" interface="tw_output"/>
    </request>

    <request name="launch_widget">
      <description summary="start the widget at point (x, y) "/>
      <arg name="tw_ui" type="new_id" interface="tw_ui"/>
      <arg name="wl_surface" type="object" interface="wl_surface"/>
      <arg name="tw_output" type="object" interface="tw_output"/>
      <arg name="x" type="uint"/>
      <arg name="y" type="uint"/>
    </request>

    <request name="create_locker">
      <description summary="create locker interface"/>
      <arg name="tw_ui" type="new_id" interface="tw_ui"/>
      <arg name="wl_surface" type="object" interface="wl_surface"/>
      <arg name="tw_output" type="object" interface="tw_output"/>
    </request>

    <!-- deprecated API -->
    <request name="set_widget">
      <arg name="surface" type="object" interface="wl_surface"/>
      <arg name="output"  type="object" interface="wl_output"/>
      <arg name= "x" type="uint"/>
      <arg name= "y" type="uint"/>
    </request>
    <request name="hide_widget">
      <description summary="destroy the widget view at the server side"/>
      <arg name="surface" type="object" interface="wl_surface"/>
    </request>

    <request name="set_panel">
      <description summary="show panel for the output">
	Panel is the for output, any input will go to commander
      </description>
      <arg name="output" type="object" interface="wl_output"/>
      <arg name="surface" type="object" interface="wl_surface"/>
    </request>

    <event name="configure">
      <description summary="send expect configuration to client">
	expected size from the server, the clients are expected to attach same
	dimension of buffer to the surface. Common usage like background, for
	example, it will be the same dimension of output. For commander, it will
	have longer width than height if vertical and vice versa.
      </description>
      <arg name="surface" type="object" interface="wl_surface"/>
      <arg name="scale" type="uint"/>
      <arg name="edges" type="uint"/>
      <arg name="width" type="int"/>
      <arg name="height" type="int"/>
    </event>
  </interface>

  <interface name="tw_output" version="1">
    <description summary="the logical output for taiwins">
      Because of wl_output interface represents a physical monitor for clients
      (corresponding to a weston_head in the compositor), we need a logical
      output representation for shell clients.
    </description>

    <event name="configure">
      <description summary="information regards to a logical output">
	The scale is confusing, when scale is 2, should it indicate the clients
	to draw twice as large or it means the output does the scale so please
	draw smaller?
      </description>
      <arg name="width" type="uint" summary="pixel width"/>
      <arg name="height" type="uint" summary="pixel height"/>
      <arg name="scale" type="uint"/>
      <arg name="x" type="int" summary="x position in the compositor"/>
      <arg name="y" type="int" summary="y position in the compositor"/>
    </event>
  </interface>

  <interface name="tw_ui" version="1">
    <description summary="UI elements like widget, panel, wallpaper">
      This interface is aming to replace panel, background, locker, widgets and
      future ui elements to come. The view is created at the time of creation,
      so no set method is required, the ui elements get removed at time of
      destruction, work much like those shell surface interface.
    </description>

    <event name="configure">
      <description summary="event to instruct clients for size and scale">
	The server decides the geometry of the widget, before this call, there
	should not be any commit, as UI layer only do the position at commit.
      </description>
      <arg name="width" type="uint"/>
      <arg name="height" type="uint"/>
      <arg name="scale" type="uint"/>
    </event>

    <event name="lose_input">
      <description summary="this ui element loses its access to input">
	we have to have an argument for this
      </description>
      <arg name="timestamp" type="uint"/>
    </event>

    <enum name="type">
      <entry name="panel" value="0"
	     summary="The panel UI is per output "/>
      <entry name="background" value="1"
	     summary="background UI element"/>
      <entry name="widget" value="2"
	     summary="light widget element to interact with"/>
    </enum>

  </interface>

  <!-- launcher interface -->
  <interface name="taiwins_launcher" version="1">
    <description summary="the launcher interface of taiwins">
      The event and request below follows the order of usage. Since this object
      is a global interface, it creates by events. So we have to be careful.
    </description>

    <event name="start">
      <description summary="instruct the client to call set_launcher">
	launching information about the launcher itself
      </description>
      <arg name="width" type="fixed"/>
      <arg name="height" type="fixed"/>
      <arg name="scale" type="fixed"/>
    </event>

    <request name="set_launcher">
      <description summary="show the launcher surface in compositor"/>
      <arg name="surface" type="object" interface="wl_surface"/>
      <arg name="exec_callback" type="new_id" interface="wl_callback"
	   summary="callback for client to exec applications"/>
      <arg name="exec_id" type="uint"/>
    </request>

    <request name="submit">
      <description summary="indicate the compositor to close the launcher surface">
	The launcher should do the submit request before the fork-exec. This
	make sure that compositor has enough up-to-dated configuration
	buffer, then it waits the wl_callback to actually exec the application.
	This is the only time that compositor updates its knowledge
	about configuration buffer to avoid the racing, you may still have
	problem when one application launches from launcher, the other starts
	somewhere else.
      </description>
      <arg name="buffer" type="object" interface="wl_buffer"/>
    </request>

    <event name="application_configure">
      <description summary="dynamically emit the application configure">
	After launching application, we could still change the preference of the
	application, when it becomes floating, tiled, scale, size change, etc.

	Notice that this event doesn't update the buffer.
      </description>
      <arg name="app_name" type="string"/>
      <arg name="floating" type="uint"/>
      <arg name="scale" type="fixed"/>
    </event>

    <!-- start-submit pair -->
    <enum name="conf">
      <entry name="stride" value="4"
	     summary="given wl_surface has another role"/>
      <entry name="num_decisions" value="100"
	     summary="xdg_shell was destroyed before children"/>
    </enum>
  </interface>

  <!-- <interface name="taiwins_launcher" version="1"> -->

  <!-- </interface> -->

</protocol>
