* Stage one: basic libweston compositor
  - have interface(shell and launcher)
  - cursor, keyboard are fully functioned.
  - be able to launch and close applications.

** [100%] fully nuklear backend (utilizing app-surface and)
     - ~nk_input_key~ and ~nk_input_unicode~ carries the text input. But the
       input box details is unknown.
*** CANC draw another triangle above nuklear widget
*** DONE research the mouse clicking problem
    Nvidia driver specific problem.
** [100%] Taiwins-shell
*** CANC lua support
    this can be *later*. It is very independent.
**** DONE adding text to widget APIs.
*** DONE memory leak checking
    My code does not have memory leak, the only problem happens with opengl drivers

**** Possible leaking ::
     - malloc but no free(I probably don't have that).
     - opened file without closing(socket, epoll, log file)
     - other system resources I am not aware of
     - libweston(-eglstream) leaks, since nvidia's implementation is not very
       serious
     - ~wl_callback~ :: there may be a wl_callback not destroyed. For this we
			would have to store the wl_callback specifically

**** DONE nuklear memory checking
**** DONE cairo memory checking


** [100%] Taiwins-launcher
*** DONE showing the luancher window
*** DONE implement text_editing                                      :client:
    Tab works
*** DONE fork-exec                                                   :client:

*** DONE change the ui element start or close implimentation

* [14%] Stage two: optimization
  - supporting multiple monitors/seats.
  - weston view focus defocus
  - a few different extensions.
  - lua support for writing extensions.
  - different layouting support
  - resize EGL windows.
  - compositing
** DONE renaming tw_shell -> shell, tw_desktop -> desktop.
   so the protocols can directly use tw_shell instead of taiwins_shell
** DOIN [62%] server-side optimization
*** CANC rename all the ctype functions
    screw that, I am not gonna do it.
*** DONE singals for adding new output and seats
*** TODO change the keyboard grab allowing the long pressing.
*** DONE updated to libweston-5
    - figure out the bug for libdrm backend.
      turned out it is my stupid pointer assignment
*** DOIN finishing weston_desktop protocols
    - resizing. DONE
    - maximizing.
    - minimizing
    - recent views
*** DOIN switch bindings into our ~run_binding~ callbacks
    looks like I need a patched version of libweston to get it to work
*** DONE have functional workspace implementation
    - workspace is implemented as keybindings
*** DONE refactring that layout implementation in workspace, it is ugly
** DOIN [66%] Configurations
*** DONE styles, nuklear and other widget styles.
    - background color.
    - Font size, font selection.
*** DONE keyboard callbacks, this writes to a buffer, apparently.
*** TODO shortcuts `taiwins_zoom`, `taiwins_alpha`. Move them into ~config.h~

** DOIN [57%] libweston-desktop implementation                       :server:
*** DOIN implement the libweston-desktop protocol                     :proto:
*** DONE desktop layer architecture
*** DONE simple random floating implementation
*** DOIN tiling layout
*** TODO client search buffer                                         :proto:
    for this to work, we probably will need ~radix tree~ or ~trie~ or hash
    table.
*** DONE decoupling the desktop implementation                    :refactory:
*** DONE include a ~last-focused-view-list~ per workspace?
    luckly that we have ~weston_desktop_suface_set_user_data~, it seems to fit
    perfectly in that position

** DOIN [83%] client-side optimization
*** TODO add udev monitoring and inotify monitoring to event_queue
*** DONE switch to epoll on wl_display
    - possible solution :: maybe we can use epoll on wl_display, and add it to
	 our event_queue, so we can call ~wl_display_dispatch_pending~. We don't
	 need another thread anymore.
*** CANC resize EGL window
    I didn't do it eventually, using different wl_surface become a solution
*** DONE shell panel refactoring
    replace the panel to nuklear implementation
*** DONE fix the cursor input problem(maybe just forget about the cursor frame callback), what is this??
*** CANC move the wl_cursor surface into shell?
    Maybe I am wrong. I do need the cursor for every application.
*** DONE widget surface launch code.
*** DONE second widget, reading batteries
*** TODO adding support for notification
*** TODO adding support for cursor menu
    right click and left click provides different functions
    - preferably right click open an menu and left click opens selection.
    - for this work you need the support for resizing
*** DONE make changes into ~tw_event_queue~
    ~tw_event_queue~ now supports more operations, you can add onetime timer then
    tell the ~queue~ to delete it afterwards, and you can change fd at runtime
    to watch on different files.

*** DONE find a way to add leading space in panel
    ~nk_spacing~ is the good solution, but you need to calculate the layout size
*** DONE fix the multiple launching bug in the panel
*** CANC add another row for panel to have better look?
*** DONE change the way the nk_button look for the icons.
*** DONE decide the way to render icons more properly.
    Right now we rely on font awesome.

    The ideal solution is render icons into glyphs. More conviniently is by
    using SVGs, since you can find them anymore. But there is no valid c or
    c++ implementation of svg2ttf. We need to rely on fontawesome for now. Now
    you need to include this [https://github.com/juliettef/IconFontCppHeaders]
    for mapping unicode symbols.
*** DOIN nk_vulkan backend
    This work is not necessary, only serves the purpose of vulkan training. But
    the API is rather verbose.
*** DONE intergrate nk_wl_egl into nk_wl_backend
    I implemented a template header of ~nk_wl_internal~, but never actually
    applies it to nk_wl_egl, it should be done very soon, so I can totally
    remove the deprecated functions.
*** DONE nk_cairo_backend multiple font support
** DOIN [33%] launcher optimization
*** DONE renaming launcher into commander, since it will does much more than just launching
*** TODO allow launcher to quit instead of launch weston-terminal all the time
*** TODO the real launcher implementation
** DOIN [50%] protocols                                               :proto:
*** DONE `tw_output` protocols to represent logical output
*** TODO `tw_desktop` output to recieve desktop events

* Stage three: extensions
*** TODO deal with scale
    you can start it by experiment with updating ~weston_matrix~
*** TODO ML based layout
*** TODO rendering/compositing optimization.
  - screen capture and screen record(audio support?).
  - westons's zoom support.

*** TODO update with damage
    currently you do only ~wl_surface_damage(0, 0, w, h)~, which causes whole
    buffer to redraw, I think there is a better solution for that.
*** TODO svg2ttf implementation
*** TODO supporting examing buffer
*** TODO build weston along with taiwins(with meson maybe)
* [20%] Bugs
** a completion based text_edit
   - ~nk_egl_get_key~ gets NoSymbol very 2 frames, so if you press Tab twice,
     what you get is Tab -> NoSymbol -> Tab -> NoSymbol. NoSymbol resets the
     state.
   - solution :: return on NoSymbol

** HARD!! compositor doesn't emit the ~done~ event for clients.
   - ~frame_callback~ was created in ~surface_state~, moved to ~surface~ at
     commit, emit ~done~ at repaint. And repaint only works if you have a view
     in the compositor. ~weston_view_unmap~ removes the view from compositor. In
     this case, the ~frame_callback~ stayed in the surface.

     In our case for the ui element, we need the frame to start and finish well,
     since next frame may starts with different content.
*** failed solution( LAGGY ):
    - unmap the view :: unmap the view removes view immediately out of any of
			~layer_list~, compositor's ~view_list~. So the frame
			~done~ would never get called either. So when the views
			move back to the layer let's say, next repaint should
			emit ~done~. However, at ~set_launcher~, we will
			immediately have another ~commit~, this can happen
			before next repaint(and it happens every time). In other
			words, so we will have one commit ahead, thus causes
			lag.
    - uses a hidden layer :: does the same thing above, since
	 ~weston_output_repaint~ does the ~view_list~ building. The view moves
	 out of the compositor before sending done.
    - do not commit in client :: cannot guarantee no commits after then submit
	 request, will also causes the lag as well.
*** UGLY solution
    - send done yourself :: copy the frame_callback struct then send the done.
*** Final solution (using frame_signal)
    the frame_signal in the ~weston_output~ struct is for the recorder. But it
    suits our case

** TODO somehow nklear did not have effects on the first draw call
   currently I have to use background color as a hack, which I hate it, or you
   can just have empty draw call
** TODO libEGL warning: FIXME: egl/x11 doesn't support front buffer rendering.
   Seems has something to do with ~EGLMakeCurrent()~.
** DONE find out why all the code point becomes `?`
   the ~nk_rune~ has to be available all the time as nuklear does not like to
   manage memory, so you cannot just pass an temporary address.
** TODO nuklear input handling has problems, the button clicked state retains
** TODO nvidia egl driver keeps giving me errors after closing an app
** TODO EGL memory leak
   after testing with cairo backend, I can be sure that my code does not contain
   any memory leak, so the problem lies within EGL side
* summarizing and planning
** <2018-12-15 Sat>
   Right now it is 1 AM at UTC-5, two weeks passed I have finally found the
   solution to render multiple fonts in cairo, it is far from what I thought it
   would be. I could not get ~cairo_user_font~ to work at all. So the solution
   became ~cairo_mask~ and ~cairo_fill~. This is a victorious moment, because
   this cairo implementation right now enjoys absolutly no memory leak. This
   puts the end of the 2018.

   Now we can actually get the taiwins shell ready. Get good point for the
   launch point then create the actual protocal for ~tw_widgets~, I suppose I
   need to give it a ~color_plus_unicodes~ approch.

   Then the shell is done(leave the right align and scale factor to next year).

** <2018-12-03 Mon>
Last two weeks I have been experiencing progress latency, it is a bit hopeless,
the original plan is to finish taiwins this year, I have 28 days left.

Right now I am at the point of struggling, there is no many new features need to
implement, but the existing features are not complete. I should be focusing on
finish those. cairo backend is the good way to do, easier to debug and nvidia
friendly. The only only problem is that I need to implement multiple font
support, I don't think it is that hard, only cairo natively supports only one
font. I am not sure how slow it is if I implement as two font type
split-draw. Or I need to go with cairo_user_font and use freetype to render it?

After this is done, then we merge everything else in place. The icons gets
render into unicodes. So we can leave user out of worry about nuklear inline
code.

Afterwards it should be the launch point debug so we can get the correct launch
point. Right now lets just render widget into a block so we don't need to draw
that small triangles. We add other callback to deal with it afterwards.

Then it should be the end of taiwins_shell, totally functional shell.

Launcher should be much simpler since it is much similar to shell.

After that I can focus on the backend code. Get it to run under console with
gbm. And implement other layouting algorithm. Alright, looks like a clear
roadmap.


** <2018-09-11 Tue>
So this is the cycle of the big refactoring, today I am finally done. I switched
panel implementation to ~nuklear~, so I am not no longer bothered by how to draw
icons and widgets. I still need to create another sample widget though, I miss
a function to launch the widget. So now I am ready, more confident on the client
side, though there are many optimization work need to be done.


** <2018-08-28 Tue>
taiwins has come to a point it can be used, maybe crash from time to time, ugly
ui, but usable. I try to list all the functionanities that I can think of then
choose one to work on, but it still confuses me right now. One side is a bug I
am not sure how to fix (EGL resizing), the otherside is a big feature(tiling
layout) that I do not want to touch now. I have to decide which side to focus
next, if I focus more on the client side, the development revolves around the
EGL, refactoring the panel to make a more pretty interface. The server side will
be more about the deplace algorithms. I am more biased towards clients since it
has been long time. If I do not currently know what is going on with EGL,
refactoring maybe a good solution.
