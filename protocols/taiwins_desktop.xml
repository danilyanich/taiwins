<protocol name="taiwins_desktop">

  <interface name="tw_shell" version="1">
    <description summary="create desktop widgets and helpers">
      Traditional user interfaces can rely on this interface to define the
      foundations of typical desktops. Currently it's possible to set up
      background, panels and locking surfaces.
    </description>

    <!-- new api, so deprecate the old set_widget and hide_widget -->
    <request name="create_panel">
      <description summary="create a new widget from wl_surface"/>
      <arg name="tw_ui" type="new_id" interface="tw_ui"/>
      <arg name="wl_surface" type="object" interface="wl_surface"/>
      <arg name="tw_output" type="int"/>
    </request>

    <request name="create_background">
      <description summary="create a background for a logical output"/>
      <arg name="tw_ui" type="new_id" interface="tw_ui"/>
      <arg name="wl_surface" type="object" interface="wl_surface"/>
      <arg name="tw_output" type="int"/>
    </request>

    <request name="launch_widget">
      <description summary="start the widget at point (x, y) "/>
      <arg name="tw_ui" type="new_id" interface="tw_ui"/>
      <arg name="wl_surface" type="object" interface="wl_surface"/>
      <arg name="tw_output" type="int"/>
      <arg name="x" type="uint"/>
      <arg name="y" type="uint"/>
    </request>

    <request name="create_locker">
      <description summary="create locker interface"/>
      <arg name="tw_ui" type="new_id" interface="tw_ui"/>
      <arg name="wl_surface" type="object" interface="wl_surface"/>
      <arg name="tw_output" type="int" />
    </request>

    <event name="output_configure">
      <description summary="signal changes of output">
	When new ouputs are created, the compositor sends this message to the
	shell client for it to create new panel or background, it can also be
	used to have the shell client responds to close of the output or change
	of dimension.

	outputs are comming in order.
      </description>
      <arg name="id" type="uint" summary="id of the output"/>
      <arg name="width" type="uint" summary="pixel width"/>
      <arg name="height" type="uint" summary="pixel height"/>
      <arg name="scale" type="uint" summary="screen scale"/>
      <arg name="major" type="uint" summary="the major output"/>
      <arg name="msg" type="uint" summary="message about the output"/>
    </event>

  <!--
    <event name="output_rotation">
    </event>

    <event name="output_done">
      <description summary="mark the end of a series output configuration"/>
      </event>
  -->

  <event name="shell_msg">
    <description summary="various configuration and msg sends to the client to
			  respond"/>
    <arg name="key" type="string"/>
    <arg name="value" type="string"/>
    
  </event>
  
    <enum name="output_msg">
      <entry name="connected" value="0" summary="output is online"/>
      <entry name="lost" value="1" summary="screen is no long available"/>
      <entry name="change" value="2" summary="output has geometry change"/>
    </enum>

    <enum name="panel_pos">
      <entry name="top" value="0"/>
      <entry name="bottom" value="1"/>
    </enum>

  </interface>

  <interface name="tw_ui" version="1">
    <description summary="UI elements like widget, panel, wallpaper">
      This interface is aming to replace panel, background, locker, widgets and
      future ui elements to come. The view is created at the time of creation,
      so no set method is required, the ui elements get removed at time of
      destruction, work much like those shell surface interface.
    </description>

    <event name="close">
      <description summary="Server no longer composites this UI element">
	Server indicates the client to destroy the wl_surface. In the case for
	panel and background, it happens when tw_output is no longer
	available. For widgets, it is an indication to close.
      </description>
    </event>

    <enum name="type">
      <entry name="panel" value="0"
	     summary="The panel UI is per output "/>
      <entry name="background" value="1"
	     summary="background UI element"/>
      <entry name="widget" value="2"
	     summary="light widget element to interact with"/>
    </enum>

  </interface>

  <!-- launcher interface -->
  <interface name="tw_console" version="1">
    <description summary="the console interface of taiwins">
      This interface acts as a shell to submit multiple commands to the
      server. It is also the port to do fork-exec.

      It has a difficult structure, the procedure complex, 1. When keybinding
      actived, server indicates the client to start the commander. 2. The client
      then needs to create the surface and request an UI element in order to
      draw on it. 3. Then after the commit, the UI appears and works like other
      application. 4. The client can choose to close the destroy the surface and
      the ui element and do nothing. 5. If it needs submit information to the
      server. It can do that now. 6. Then If server needs it to exec an
      application. It will pass the `exec` command to the client.

      The first 3 event/request works like TCP/IP, clients waits for ACK to do
      the next. But once started. It can perform quickly.
    </description>
    <event name="start">
      <description summary="instruct the client to call launch">
	launching information about the launcher itself
      </description>
      <arg name="width" type="fixed"/>
      <arg name="height" type="fixed"/>
      <arg name="scale" type="fixed"/>
    </event>

    <request name="launch">
      <description summary="Actaully start the launcher">
	This request must act as an action results from start event
      </description>
      <arg name="ui_elem" type="new_id" interface="tw_ui"/>
      <arg name="surface" type="object" interface="wl_surface"/>
    </request>

    <request name="submit">
      <description summary="indicate the compositor to close the launcher surface">
	The launcher should do the submit request before the fork-exec. This
	make sure that compositor has enough up-to-dated configuration
	buffer, then it waits the wl_callback to actually exec the application.
	This is the only time that compositor updates its knowledge
	about configuration buffer to avoid the racing, you may still have
	problem when one application launches from launcher, the other starts
	somewhere else.
      </description>
      <arg name="buffer" type="object" interface="wl_buffer"/>
      <arg name="exec_id" type="uint">
	<description summary="exec_id is records current index of process starting"/>
      </arg>
    </request>

    <event name="exec">
      <description summary="indicate the launcher could perform fork-exec">
	it is a response from the submit request
      </description>
      <arg name="exec_id" type="uint"/>
    </event>

    <event name="application_configure">
      <description summary="dynamically emit the application configure">
	After launching application, we could still change the preference of the
	application, when it becomes floating, tiled, scale, size change, etc.

	Notice that this event doesn't update the buffer.
      </description>
      <arg name="app_name" type="string"/>
      <arg name="floating" type="uint"/>
      <arg name="scale" type="fixed"/>
    </event>

    <!-- start-submit pair -->
    <enum name="conf">
      <entry name="stride" value="4"
	     summary="given wl_surface has another role"/>
      <entry name="num_decisions" value="100"
	     summary="xdg_shell was destroyed before children"/>
    </enum>
  </interface>
<!--
  <interface name="tw_theme">
    <event name="main_font">
      <arg name="path" type="string"/>
    </event>

    <event name="icon_font">
      <arg name="path" type="string"/>
    </event>

    <event name="font size">
      <arv name="pt" type="uint" summary="point size"/>
    </event>

    <event name="base color">
      <arg name="red" type="uint"/>
      <arg name="green" type="uint"/>
      <arg name="blue" type="uint"/>
      <arg name="transparency" type="fixed" summary="between 0 and 1"/>
    </event>

    <event name="done">
      <description summary="mark the end of a theme configuration"/>
    </event>

  </interface>
-->
</protocol>
