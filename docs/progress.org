* Stage one: basic libweston compositor
  - have interface(shell and launcher)
  - cursor, keyboard are fully functioned.
  - be able to launch and close applications.

** [100%] fully nuklear backend (utilizing app-surface and)
     - ~nk_input_key~ and ~nk_input_unicode~ carries the text input. But the
       input box details is unknown.
*** CANC draw another triangle above nuklear widget
*** DONE research the mouse clicking problem
    Nvidia driver specific problem.
** [100%] Taiwins-shell
*** CANC lua support
    this can be *later*. It is very independent.
**** DOIN adding text to widget APIs.
*** DONE memory leak checking
**** Possible leaking ::
     - malloc but no free(I probably don't have that).
     - opened file without closing(socket, epoll, log file)
     - other system resources I am not aware of
     - libweston(-eglstream) leaks, since nvidia's implementation is not very
       serious
     - ~wl_callback~ :: there may be a wl_callback not destroyed. For this we
			would have to store the wl_callback specifically

**** DONE nuklear memory checking
**** DONE cairo memory checking

** [100%] Taiwins-launcher
*** DONE showing the luancher window
*** DONE implement text_editing                                      :client:
    Tab works
*** DONE fork-exec                                                   :client:

*** DONE change the ui element start or close implimentation

* Stage two: optimization
  - supporting multiple monitors/seats.
  - weston view focus defocus
  - a few different extensions.
  - lua support for writing extensions.
  - different layouting support
  - resize EGL windows.
  - compositing
** [66%] server-side optimization
*** DONE singals for adding new output and seats
*** TODO change the keyboard grab allowing the long pressing.
*** DONE updated to libweston-5
** [33%] Configurations
*** TODO styles, nuklear and other widget styles.
    - background color.
    - Font size, font selection.
*** DONE keyboard callbacks, this writes to a buffer, apparently.
*** TODO shortcuts `taiwins_zoom`, `taiwins_alpha`.

** [60%] libweston-desktop implementation                            :server:
*** TODO implement the libweston-desktop protocol                     :proto:
*** DONE desktop layer architecture
*** DONE simple random floating implementation
*** TODO tiling layout


*** TODO client search buffer                                         :proto:
    for this to work, we probably will need ~radix tree~ or ~trie~ or hash
    table.
*** DONE decoupling the desktop implementation                    :refactory:

** [50%] client-side optimization
*** DONE switch to epoll on wl_display
    - possible solution :: maybe we can use epoll on wl_display, and add it to
	 our event_queue, so we can call ~wl_display_dispatch_pending~. We don't
	 need another thread anymore.
*** CANC resize EGL window
    I didn't do it eventually, using different wl_surface become a solution
*** TODO shell panel refactoring
    - easily create and destroy ~app_surface~.
    - make icon a app_surface as well, so we do not need to create new buffer
      for it?
*** TODO fix the cursor input problem(maybe just forget about the cursor frame callback), what is this??
** [0%] protocols                                                     :proto:
*** TODO `tw_output` protocols to represent logical output
*** TODO `tw_desktop` output to recieve desktop events

* Stage three: extensions
*** TODO ML based layout
*** TODO rendering/compositing optimization.
  - screen capture and screen record(audio support?).
  - westons's zoom support.



*** TODO supporting examing buffer
*** TODO build weston along with taiwins(with meson maybe)
* Bugs
** a completion based text_edit
   - ~nk_egl_get_key~ gets NoSymbol very 2 frames, so if you press Tab twice,
     what you get is Tab -> NoSymbol -> Tab -> NoSymbol. NoSymbol resets the
     state.
   - solution :: return on NoSymbol

** HARD!! compositor doesn't emit the ~done~ event for clients.
   - ~frame_callback~ was created in ~surface_state~, moved to ~surface~ at
     commit, emit ~done~ at repaint. And repaint only works if you have a view
     in the compositor. ~weston_view_unmap~ removes the view from compositor. In
     this case, the ~frame_callback~ stayed in the surface.

     In our case for the ui element, we need the frame to start and finish well,
     since next frame may starts with different content.
*** failed solution( LAGGY ):
    - unmap the view :: unmap the view removes view immediately out of any of
			~layer_list~, compositor's ~view_list~. So the frame
			~done~ would never get called either. So when the views
			move back to the layer let's say, next repaint should
			emit ~done~. However, at ~set_launcher~, we will
			immediately have another ~commit~, this can happen
			before next repaint(and it happens every time). In other
			words, so we will have one commit ahead, thus causes
			lag.
    - uses a hidden layer :: does the same thing above, since
	 ~weston_output_repaint~ does the ~view_list~ building. The view moves
	 out of the compositor before sending done.
    - do not commit in client :: cannot guarantee no commits after then submit
	 request, will also causes the lag as well.
*** UGLY solution
    - send done yourself :: copy the frame_callback struct then send the done.
*** Final solution (using frame_signal)
    the frame_signal in the ~weston_output~ struct is for the recorder. But it
    suits our case


* summarizing and planning
** <2018-08-28 Tue>
taiwins has come to a point it can be used, maybe crash from time to time, ugly
ui, but usable. I try to list all the functionanities that I can think of then
choose one to work on, but it still confuses me right now. One side is a bug I
am not sure how to fix (EGL resizing), the otherside is a big feature(tiling
layout) that I do not want to touch now. I have to decide which side to focus
next, if I focus more on the client side, the development revolves around the
EGL, refactoring the panel to make a more pretty interface. The server side will
be more about the deplace algorithms. I am more biased towards clients since it
has been long time. If I do not currently know what is going on with EGL,
refactoring maybe a good solution.
