So far I've made so many data structures in *taiwins* for the organizing code,
the problem is that every structure created on the fly, so the history of the
design carries on.

* The rotten issues in the project
The short-sighted design of the taiwins, lack of knowledge and design skills;
Lack of understanding of wayland and weston design (personally I think weston has
way more crumbosome design).

Some quick hacks that I did to get things working. For example, I used to think
every client has only one ~wl_surface~ and I was immediately wrong, also the way
I handled the time counter (with two threads), come on.


* Client data structures
  - wl_global :: the global structure that fits the need of an wayland client.
		 It contains things like ~wl_shm~, ~wl_shm_format~,
		 ~wl_compositor~, ~wl_display~.
    * Inputs :: I only have one input per client, fair enough, why
    would you need two seats if only one person operates it.

  - tw_event_loop :: introduced for ~tw_shell~ to handle system generated events
		     like time lapse and wayland protocol events.
    * tw_event :: this leads to another interface for use to
    create its own event and watch the event. It didn't go as
    far as the ~wl_protocols~ where you create custom protocols
    and have handlers for them.

  - shm_pool :: the allocator for shared buffers, binds to ~wl_buffer~.

Then there are the UI elements
** UIs
   - app_surface :: now you have an app surface, it kinda binds to an
		    ~wl_surface~. The surface has it implementation of buffer
		    and input events, it has the data but no actual methods to
		    interact with it. ~app_surface~ was first created for
		    distinguishing background surface and panel surface. So in a
		    sense, now we have three different kinds of ~app_surface~,
		    background, panel, widget.

		    As an ~app_surface~, it has it's own ~<x,y,w,h>~ values. Or
		    you can

   - tw_ui :: plays the role like ~wl_shell_surface~ as a bridge between server
	      and clients. Otherwise server does not know how to update it. With
	      that in mind, the ~app_surface.proxy~ is the ~tw_ui~.

*** The pitfalls of app_surface
~app_surface~ has evolved for too long and too much overhead (Not as much as
~nk_backend~). It has three constructors, know the EGL and shared buffer. It has
init but only does part of the job. I should really make it whole, init with
different implementation and that is it.

If app_surface created with buffer, you call ~app_surface_fadc~. Otherwise it is
done by subroutines. I don't like it. The commit job should be here


*** nuklear backend
The nuklear backend is the implementation of an GUI with the ~wl_buffer~ from
~app_surface~. It was designed to support different surface at the same time
then I found out I cannot really do it.

** Taiwins Shell specific structure.
