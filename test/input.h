#ifndef TW_INPUT_H
#define TW_INPUT_H

#include <search.h>
#include <unistd.h>
#include <xkbcommon/xkbcommon.h>
#include <xkbcommon/xkbcommon-names.h>
#include <xkbcommon/xkbcommon-keysyms.h>
#include <linux/input.h>
#include <compositor.h>
#include <sequential.h>

#ifdef __cplusplus
extern "C" {
#endif



/**
 * thanks to the knowledge by archwiki, the xkbcommon is the library that does
 * all the mapping, it has
 * - model:"pc105, pc104, cheryblue, emachines...",
 * - layouts: "languages like us, fr",
 * - variants: "dvorak" keyboard for us layouts, anyway, people always wanna new
     different keyboard.
 * - options: the one I use is 'switch lctrl-lalt'
 *
 * In weston, the key event is called by generated by notify_key, some backends
 * like x11/wayland will call it directly, drm seems to have different
 * approaches since it is more complecated. You should add the seat created
 * signal though. well, anyway. We are getting the input
 *
 */
struct tw_keypress {
	xkb_keysym_t keysym;
	//used in weston_compositor_add_keybindings, because there is no
	//implementation transfer(keysym to keycode)
	uint32_t keycode; //the linux keycode
	enum weston_keyboard_modifier modifiers; //the weston modifier
};


//int compare_keypress(const void *a, const void *b);
//void print_keypress (const void *nodep, VISIT value, int level);

//yoo, I should define bunch of hotkey function.
typedef void (*shortcut_func_t)(void);


void update_tw_keymap_tree(const vector_t *keyseq, const shortcut_func_t func);

void update_tw_keypress_cache(const vector_t *keyseq, struct weston_compositor *compositor);

void
run_keybinding_wayland(struct xkb_state *state, uint32_t time, uint32_t key,
		       void *data);
void
run_keybinding(struct weston_keyboard *keyboard,
	       uint32_t time, uint32_t key,
	       void *data);


void debug_keybindtree(void);


#ifdef __cplusplus
}
#endif




#endif /* EOF */
